# Теоретическая часть 

## Парадигмы программирования

Существует несколько подходов к программированию — парадигм программирования.

Python реализует не только процедурное (структурное) программирование, но и объектно-ориентированное.

* Императивное программирование — программа пишется как последовательность инструкций для компьютера.
* Процедурное (структурное) программирование — это развитие императивной парадигмы программирования. В программе создаются вспомогательные блоки (функции, модули, пакеты) каждый из которых выполяет небольшую часть работы программы.
* Объектно-ориентированное программирование — программист описывает поведение программных объектов (которые моделируют поведение реальных объектов), программа является взаимодействием таких объектов.

## Терминология

**Класс** — это тип данных. Например строки (`str`) или списки (`list`) — это классы. Классы могут моделировать категории реальных или абстрактных объектов. Например можно написать класс `Auto` для описания различных автомобилей или можно написать класс `Character` для описания персонажей игры.

Имена классов следует начинать с заглавной буквы. Если имя класса состоит из нескольких слов — начинайте каждое новое слово с заглавной буквы (см. [CamelCase](https://ru.wikipedia.org/wiki/CamelCase)).

**Объект** — это переменная некоторого типа данных (конкретный экземпляр класса). В программе можно создать несколько переменных одного и того же класса (например несколько строк или списков). Все они будут вести себя одинаково, но будут хранить разные данные.

Имена объектов (переменных) следует писать строчными буквами (в нижнем регистре). Если имя состоит из нескольких слов — соедините их с помощью символа подчеркивания (см. [snake_case](https://ru.wikipedia.org/wiki/Snake_case)).

**Атрибут** — это элементарный кусочек данных, которые хранит в себе объект. Например, если объект описывает автомобиль, то это может быть мощность двигателя или количество бензина в баке.

Атрибуты могут быть индивидуальными для каждого объекта, а могут быть общими для всего класса (статические). Если у объекта есть два одинаково называющихся атрибута обоих видов, то преимущество имеет индивидуальный атрибут.

Чтобы обратиться к атрибуту, нужно написать его имя после точки.

**Метод** — это функция, которая привязана к классу. Методы описывают поведение объектов класса.

Чтобы обратиться к методу, нужно написать его имя после точки. Чтобы вызвать метод, нужно написать после его имени круглые скобки.

Имена объектов, атрибутов и методов следует писать строчными буквами. Если имя состоиз из нескольких слов — соедините их с помощью символа подчеркивания ([snake_case](https://ru.wikipedia.org/wiki/Snake_case)).

## Объявление класса

Для объявления класса служит ключевое слово class.

Минимальное объявление класса выглядит так:

```python
class Dog:
    pass
```

Чтобы создать объект класса нужно после имени класса написать круглые скобки (аналогично вызову функции):

```python
sharik = Dog()
```

В классе могут объявлены атрибуты (общие для всех объектов класса):

```python
class Dog:
    legs = 4
```

Для каждого объекта класса могут быть свои атрибуты (индивидуальные для объекта):

```python
sharik = Dog()
sharik.name = 'Шарик'
lassie = Dog()
lassie.name = 'Лесси'
print(sharik.name)  # Шарик
```

Каждому методу класса неявно передается аргумент `self` — указатель на объект класса:

```python
class Dog():
    def gav(self):
        print(f'Привет, меня зовут {self.name}')

sharik = Dog()
sharik.name = 'Шарик'
sharik.gav()  # Привет, меня зовут Шарик
```

Атрибуты объектов могут быть созданы динамически внутри методов:

```python
class Dog():
    def set_name(self, name):
        self.name = name

sharik = Dog()
sharik.set_name('Шарик')
print(sharik.name)  # Шарик
```

## Инкапсуляция

В объектно-ориентированном программировании принцип **инкапсуляции** утверждает что поведение объектов зависит от ихвнутреннего состояния. Внутреннее состояние объекта — это совокупность значений его атрибутов. Чтобы уменьшить количество ошибок в программном коде объекты должны ограничивать доступ к важным атрибутам внутреннего состояния.

Для того, чтобы показать, что атрибут или метод не должны использоваться за его пределами, следует начинать его имя с символа "_" (подчеркивание).

Для того, чтобы запретить использование атрибута или метода следует начинать его идентификатор с символов "__" (двойное подчеркивание).

```python
class Batman:
    _secret_info = 'Robin is Dick Grayson'
    __supersecret = 'Batman is Bruce Wayne'

batman = Batman()
print(batman._secret)  # 'Robin is Dick Grayson'
print(batman.__supersecret)  # Ошибка, т.к. атрибут недоступен извне объекта
```

Принцип **Инкапсуляции** утверждает что следует разделять внутреннюю и внешнюю стороны объектов. Внешняя сторона (интерфейс) описывает как объект взаимодействует с другими объектами. Внутренняя сторона (реализация) описывает как он устроен и как работает.

Применение принципа инкапсуляции позволяет изменять детали внутренней реализации (например применить новый более эффективный алгоритм) без изменения внешнего интерейса. При этом, другие части программы не нужно будет изменять.

## Наследование

**Наследование** — это принцип ООП согласно которому класс может унаследовать от другого класса его атрибуты и методы.

Исходный класс называется **базовым** или **родительским** (иногда **суперклассом**).

Порожденный класс называется **производным** или **дочерним** (иногда **подклассом**).

```python
class Animal:
    def test(self):
        print('Меня зовут', self.name)

class Dog(Animal):  # базовый класс в скобках
    def bark(self):
        self.test()  # обращение к методу родительского класса

class Cat(Animal):  # базовый класс в скобках
    def meow(self):
        self.test()  # обращение к методу родительского класса

gav = Cat()
gav.name = 'Гав'
gav.meow()  # Меня зовут Гав
gav.test()  # Меня зовут Гав
gav.bark()  # Ошибка
```

Python поддерживает множественное наследование, т.е. у класса может быть несколько родительских классов:

```python
class Father:
    chromosome_Y = True

class Mother:
    chromosome_X = True

class Child(Father, Mother):
    pass

child = Child()
dir(child)  # производный класс имеет оба атрибута: chromosome_Y и chromosome_X
```

Производный класс может модифицировать поведение базового класса. То есть, в производном классе можно переопределить атрибуты и методы базового класса.

При поиске конкретного атрибута или метода сначала просматривается производный класс, потом его базовый класс и т.д.

Если использовано множественное наследование, то классы на одном уровне просматриваются слева направо.

# Полиморфизм

**Полиморфизм** — это принцип ООП согласно которому если функция умеет работать с объектами базового класса, то она без изменений может работать с объектами производных классов.

При этом часто функции не знают объекты какого конкретно класса её передадут, базового или одного из производных.

```python
class Animal:
    def test(self):
        print('I am an animal')

class Dog(Animal):
    pass

class Cat(Animal):
    def test(self):
        print('I am a cat')

def test_animal(animal):
    # Функция не знает какой конкретно метод будет вызван
    animal.test()

sharik = Dog()
test_animal(sharik)  # I am an animal

gav = Cat()
test_animal(gav)  # I am a cat
```

## Конструктор

Метод с именем `__init__()` вызывается при создании объекта и называется конструктором. Этот метод используется для инициализации объекта класса при его создании:

```python
class Dog:
    name = ''
    def __init__(self, name):
        self.name = name

sharik = Dog('Шарик')
print(sharik.name)  # Шарик
```

## Функция super()

Функция super() позволяет получить ссылку на родительский класс:

```python
class Animal:
    name = ''
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # вызов родительского конструктора
        self.breed = breed

lassie = Dog('Лесси', 'Колли')
print(lassie.name)  # Лесси
print(lassie.breed)  # Колли
```
