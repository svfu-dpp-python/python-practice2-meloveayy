# ​Парадигмы программирования

Существует несколько подходов к программированию — парадигм программирования.

Python реализует не только процедурное (структурное) программирование, но и объектно-ориентированное.

* Императивное программирование — программа пишется как последовательность инструкций для компьютера.
* Процедурное (структурное) программирование — это развитие императивной парадигмы программирования. В программе создаются вспомогательные блоки (функции, модули, пакеты) каждый из которых выполяет небольшую часть работы программы.
* Объектно-ориентированное программирование — программист описывает поведение программных объектов (которые моделируют поведение реальных объектов), программа является взаимодействием таких объектов.

# Терминология

**Класс** — это тип данных. Например строки (`str`) или списки (`list`) — это классы. Классы могут моделировать категории реальных или абстрактных объектов. Например можно написать класс `Auto` для описания различных автомобилей или можно написать класс `Character` для описания персонажей игры.

Имена классов следует начинать с заглавной буквы. Если имя класса состоит из нескольких слов — начинайте каждое новое слово с заглавной буквы ([CamelCase](https://ru.wikipedia.org/wiki/CamelCase)).

**Объект** — это переменная некоторого типа данных (конкретный экземпляр класса). В программе можно создать несколько переменных одного и того же класса (например несколько строк или списков). Все они будут вести себя одинаково, но будут хранить разные данные.

Имена объектов (переменных) следует писать строчными буквами. Если имя состоиз из нескольких слов — соедините их с помощью символа подчеркивания ([snake_case](https://ru.wikipedia.org/wiki/Snake_case)).

**Атрибут** — это часть данных, которые хранит в себе объект. Например если объект описывает автомобиль, то это может быть мощность двигателя или количество бензина в баке.

Атрибуты могут быть индивидуальные для каждого объекта, а могут быть общие для всего класса (статические).

Чтобы обратиться к атрибуту, нужно написать его имя после точки.

**Метод** — это функция, которая привязана к классу. Методы описывают поведение объектов класса.

Чтобы обратиться к методу, нужно написать его имя после точки. Чтобы вызвать его, нужно написать справа круглые скобки.

Имена объектов, атрибутов и методов следует писать строчными буквами. Если имя состоиз из нескольких слов — соедините их с помощью символа подчеркивания ([snake_case](https://ru.wikipedia.org/wiki/Snake_case)).

# Объявление класса

Для объявления класса служит ключевое слово class.

Минимальное объявление класса выглядит так:

```python
class Dog:
    pass
```

Чтобы создать объект класса нужно написать справа круглые скобки (аналогично вызову функции):

```python
sharik = Dog()
```

В классе могут объявлены атрибуты (общие для всех объектов класса):

```python
class Dog:
    legs = 4
```

Для каждого объекта класса могут быть свои атрибуты (индивидуальные для объекта):

```python
sharik = Dog()
sharik.name = 'Шарик'
lassie = Dog()
lassie.name = 'Лесси'
print(sharik.name)  # Шарик
```

Каждому методу класса неявно передается аргумент `self` — указатель на объект класса:

```python
class Dog():
    def gav(self):
        print(f'Привет, меня зовут {self.name}')

sharik = Dog()
sharik.name = 'Шарик'
sharik.gav()  # Привет, меня зовут Шарик
```

Атрибуты объектов могут быть созданы динамически внутри методов:

```python
class Dog():
    def set_name(self, name):
        self.name = name

sharik = Dog()
sharik.set_name('Шарик')
print(sharik.name)  # Шарик
```

# Инкапсуляция

Для того, чтобы показать, что атрибут или метод не должны использоваться за его пределами, следует начать его имя с символа "_" (подчеркивание).

Для того, чтобы запретить использование атрибута или метода следует начать его идентификатор с символов "__" (двойное подчеркивание).

```python
class Batman:
    def _secret(self):
        print('Robin is Dick Grayson')

    def __supersecret(self):
        print('Batman is Bruce Wayne')

batman = Batman()
batman._secret()  # 'Robin is Dick Grayson'
batman.__supersecret()  # Ошибка
```

**Инкапсуляция** — это принцип ООП, согласно которому следует разделять внутреннюю и внешнюю стороны объектов. Внешняя сторона (интерфейс) описывает как объект взаимодействует с другими объектами. Внутренняя сторона (реализация) описывает как он устроен и как работает.

Принципа инкапсуляции приводит к тому что если в объекте измененились детали внутренней реализации без изменения внешнего интерейса, то программа в целом продолжит работать как прежде.

# Наследование

**Наследование** — это принцип ООП согласно которому класс может унаследовать от другого класса его атрибуты и методы.

Исходный класс называется **базовым** или **родительским** (иногда **суперклассом**).

Порожденный класс называется **производным** или **дочерним** (иногда **подклассом**).

```python
class Animal:
    def test(self):
        print('Меня зовут', self.name)

class Dog(Animal):  # базовый класс в скобках
    def bark(self):
        self.test()

class Cat(Animal):  # базовый класс в скобках
    def meow(self):
        self.test()

gav = Cat()
gav.name = 'Гав'
gav.meow()  # Меня зовут Гав
gav.test()  # Меня зовут Гав
gav.bark()  # Ошибка
```

Python поддерживает множественное наследование:

```python
class Father:
    chromosome_Y = True

class Mother:
    chromosome_X = True

class Child(Father, Mother):
    pass

child = Child()
dir(child)  # chromosome_Y, chromosome_X
```

Производный класс может модифицировать поведение базового класса. То есть, в производном классе можно переопределить атрибуты и методы базового класса.

При поиске конкретного атрибута или метода сначала просматривается производный класс, потом его базовый класс и т.д.

Если использовано множественное наследование, то классы на одном уровне просматриваются слева направо.

# Полиморфизм


**Полиморфизм** — это принцип ООП согласно которому если функция умеет работать с объектами базового класса, то она без изменений может работать с объектами производных классов.

При этом функция не знает объект какого конкретно класса её передадут, базового или одного из производных.

```python
class Animal:
    def test(self):
        print('I am an animal')

class Dog(Animal):
    pass

class Cat(Animal):
    def test(self):
        print('I am a cat')

def test_animal(animal):
    # Функция не знает какой конкретно метод будет вызван
    animal.test()

sharik = Dog()
test_animal(sharik)  # I am an animal

gav = Cat()
test_animal(gav)  # I am a cat
```

# Конструктор

Метод с именем `__init__()` вызывается при создании объекта и называется конструктором:

```python
class Dog:
    name = ''
    def __init__(self, name):
        self.name = name

sharik = Dog('Шарик')
print(sharik.name)  # Шарик
```

# Функция super()

Функция super() позволяет обратиться к родительскому классу:

```python
class Animal:
    name = ''
    def __init__(self, name):
        name = self.name

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)
        self.breed = breed

lassie = Dog('Лесси', 'Колли')
print(lassie.name)  # Лесси
print(lassie.breed)  # Колли
```
